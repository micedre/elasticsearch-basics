{
  "hash": "fd0a0746914ab127d909756c6db21967",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Core Concepts\"\n---\n\n## Understanding Elasticsearch Architecture\n\nElasticsearch is built on several key concepts that work together to provide powerful search and analytics capabilities.\n\n## Documents\n\nA **document** is the basic unit of information in Elasticsearch. It's a JSON object that contains your data.\n\n::: {#4bbd9cac .cell execution_count=1}\n``` {.python .cell-code}\n# Example document\ndocument = {\n    \"title\": \"Introduction to Elasticsearch\",\n    \"author\": \"John Doe\",\n    \"published_date\": \"2024-01-15\",\n    \"content\": \"Elasticsearch is a powerful search engine...\",\n    \"tags\": [\"search\", \"elasticsearch\", \"tutorial\"],\n    \"views\": 1250,\n    \"rating\": 4.5\n}\n```\n:::\n\n\n### Key Points about Documents:\n\n- Documents are expressed in JSON format\n- Each document has a unique ID (auto-generated or specified)\n- Documents are schema-free but benefit from explicit mapping\n- Similar to a row in a relational database\n\n## Indices\n\nAn **index** is a collection of documents with similar characteristics. Think of it as a database in traditional systems.\n\n::: {#d65c9133 .cell execution_count=2}\n``` {.python .cell-code}\n# Index naming conventions\nindex_name = \"blog_posts\"  # lowercase, no special characters\n\n# Multiple indices can exist\nindices = [\n    \"blog_posts\",\n    \"user_profiles\",\n    \"product_catalog\",\n    \"log_data_2024\"\n]\n```\n:::\n\n\n### Index Characteristics:\n\n- Identified by a lowercase name\n- Contains documents of similar type\n- Can be optimized for specific use cases\n- Supports custom settings and mappings\n\n## Mapping\n\n**Mapping** defines how documents and their fields are stored and indexed. It's similar to a schema in relational databases.\n\n::: {#e201793c .cell execution_count=3}\n``` {.python .cell-code}\n# Example mapping definition\nmapping = {\n    \"properties\": {\n        \"title\": {\n            \"type\": \"text\",\n            \"analyzer\": \"english\"\n        },\n        \"author\": {\n            \"type\": \"keyword\"  # Not analyzed, exact matches\n        },\n        \"published_date\": {\n            \"type\": \"date\",\n            \"format\": \"yyyy-MM-dd\"\n        },\n        \"content\": {\n            \"type\": \"text\"\n        },\n        \"tags\": {\n            \"type\": \"keyword\"\n        },\n        \"views\": {\n            \"type\": \"integer\"\n        },\n        \"rating\": {\n            \"type\": \"float\"\n        }\n    }\n}\n```\n:::\n\n\n### Common Field Types:\n\n| Type | Description | Example Use Case |\n|------|-------------|------------------|\n| `text` | Full-text searchable | Article content, descriptions |\n| `keyword` | Exact value matching | Tags, categories, IDs |\n| `date` | Date/time values | Published dates, timestamps |\n| `integer`/`long` | Whole numbers | Counts, IDs |\n| `float`/`double` | Decimal numbers | Ratings, prices |\n| `boolean` | True/false | Flags, status |\n| `object` | Nested JSON object | Complex structures |\n| `geo_point` | Latitude/longitude | Location data |\n\n## Shards and Replicas\n\nElasticsearch distributes data across **shards** for scalability and **replicas** for high availability.\n\n### Shards\n\n- An index is divided into multiple shards\n- Each shard is a fully functional index\n- Enables horizontal scaling\n- Default: 1 primary shard per index\n\n### Replicas\n\n- Copies of primary shards\n- Provides redundancy and increased search capacity\n- Default: 1 replica per primary shard\n\n::: {#5fe62f60 .cell execution_count=4}\n``` {.python .cell-code}\n# Creating an index with custom shard settings\nindex_settings = {\n    \"settings\": {\n        \"number_of_shards\": 3,      # Primary shards\n        \"number_of_replicas\": 2      # Replica copies\n    },\n    \"mappings\": {\n        \"properties\": {\n            \"title\": {\"type\": \"text\"},\n            \"content\": {\"type\": \"text\"}\n        }\n    }\n}\n\n# Note: This is the structure; we'll see how to apply it in the next section\n```\n:::\n\n\n:::{.callout-note}\n## Shard Strategy\n- More shards = better distribution but higher overhead\n- Choose shard count based on expected data volume\n- Cannot change shard count after index creation (requires reindexing)\n:::\n\n## Nodes and Clusters\n\n### Cluster\n\n- A collection of nodes that work together\n- Stores all your data\n- Provides indexing and search capabilities\n- Identified by a unique name\n\n### Node\n\n- A single server in the cluster\n- Stores data and participates in indexing/searching\n- Can have different roles:\n  - **Master node**: Cluster management\n  - **Data node**: Stores data and executes queries\n  - **Ingest node**: Pre-processes documents\n  - **Coordinating node**: Routes requests\n\n::: {#7c21ef71 .cell execution_count=5}\n``` {.python .cell-code}\nfrom elasticsearch import Elasticsearch\n\nes = Elasticsearch(['http://localhost:9200'])\n\n# Get cluster information\ncluster_info = es.cluster.stats()\n\nprint(f\"Cluster name: {cluster_info['cluster_name']}\")\nprint(f\"Number of nodes: {cluster_info['nodes']['count']['total']}\")\nprint(f\"Indices count: {cluster_info['indices']['count']}\")\n\n# Get node information\nnodes = es.nodes.info()\nfor node_id, node_data in nodes['nodes'].items():\n    print(f\"Node: {node_data['name']}\")\n    print(f\"  Roles: {', '.join(node_data['roles'])}\")\n```\n:::\n\n\n## Inverted Index\n\nElasticsearch uses an **inverted index** for fast full-text searches.\n\n### How it Works:\n\n1. Text is analyzed and broken into terms\n2. Terms are stored with references to documents\n3. Searches look up terms in the index\n4. Results are retrieved almost instantly\n\n::: {#c5a0e399 .cell execution_count=6}\n``` {.python .cell-code}\n# Example: How text is analyzed\ntext = \"The quick brown fox jumps over the lazy dog\"\n\n# After analysis (simplified):\ninverted_index = {\n    \"quick\": [\"doc1\"],\n    \"brown\": [\"doc1\"],\n    \"fox\": [\"doc1\"],\n    \"jump\": [\"doc1\"],  # stemmed from \"jumps\"\n    \"lazi\": [\"doc1\"],  # stemmed from \"lazy\"\n    \"dog\": [\"doc1\"]\n}\n\n# Note: Common words like \"the\", \"over\" are often removed (stop words)\n```\n:::\n\n\n## Analysis and Analyzers\n\n**Analyzers** process text during indexing and searching. They consist of:\n\n1. **Character filters**: Remove/replace characters\n2. **Tokenizers**: Break text into tokens\n3. **Token filters**: Modify tokens (lowercase, stemming, etc.)\n\n::: {#dec398b9 .cell execution_count=7}\n``` {.python .cell-code}\n# Example: Testing an analyzer\nanalyze_request = {\n    \"analyzer\": \"english\",\n    \"text\": \"The Quick Brown Foxes jumped over the lazy dogs\"\n}\n\n# This would produce tokens like:\n# [\"quick\", \"brown\", \"fox\", \"jump\", \"lazi\", \"dog\"]\n# Notice: lowercase, stemmed, stop words removed\n```\n:::\n\n\n### Common Analyzers:\n\n- `standard`: Default, good for most languages\n- `english`: English language specific\n- `keyword`: No analysis, exact matching\n- `whitespace`: Split on whitespace only\n- `simple`: Lowercase and split on non-letters\n\n:::{.callout-tip}\n## Understanding Analysis\nProper analyzer selection is crucial for good search results. Choose based on your data type and search requirements.\n:::\n\n## Data Types in Practice\n\nLet's see how different data types affect searching:\n\n::: {#46b44fe0 .cell execution_count=8}\n``` {.python .cell-code}\n# Example mapping with different types\nproduct_mapping = {\n    \"properties\": {\n        # Text: searchable, analyzed\n        \"description\": {\n            \"type\": \"text\",\n            \"analyzer\": \"english\"\n        },\n\n        # Keyword: exact match, aggregations, sorting\n        \"category\": {\n            \"type\": \"keyword\"\n        },\n\n        # Multi-field: both text and keyword\n        \"name\": {\n            \"type\": \"text\",\n            \"fields\": {\n                \"keyword\": {\n                    \"type\": \"keyword\"\n                }\n            }\n        },\n\n        # Numeric: range queries, aggregations\n        \"price\": {\n            \"type\": \"float\"\n        },\n\n        # Date: date math, range queries\n        \"created_at\": {\n            \"type\": \"date\"\n        },\n\n        # Boolean: true/false filters\n        \"in_stock\": {\n            \"type\": \"boolean\"\n        },\n\n        # Nested: complex objects\n        \"reviews\": {\n            \"type\": \"nested\",\n            \"properties\": {\n                \"author\": {\"type\": \"keyword\"},\n                \"rating\": {\"type\": \"integer\"},\n                \"comment\": {\"type\": \"text\"}\n            }\n        }\n    }\n}\n```\n:::\n\n\n## Summary\n\nKey concepts to remember:\n\n1. **Documents**: JSON objects containing your data\n2. **Indices**: Collections of similar documents\n3. **Mapping**: Schema definition for documents\n4. **Shards**: Distribute data for scalability\n5. **Replicas**: Provide redundancy and availability\n6. **Nodes/Clusters**: Infrastructure components\n7. **Inverted Index**: Data structure enabling fast searches\n8. **Analyzers**: Text processing for search\n\n:::{.callout-tip}\n## Ready for Practice?\nIn the next section, we'll put these concepts into action by indexing and managing documents!\n:::\n\n",
    "supporting": [
      "core-concepts_files"
    ],
    "filters": [],
    "includes": {}
  }
}