---
title: "Core Concepts"
---

## Understanding Elasticsearch Architecture

Elasticsearch is built on several key concepts that work together to provide powerful search and analytics capabilities.

## Documents

A **document** is the basic unit of information in Elasticsearch. It's a JSON object that contains your data.

```{python}
#| echo: true
#| eval: false

# Example document
document = {
    "title": "Introduction to Elasticsearch",
    "author": "John Doe",
    "published_date": "2024-01-15",
    "content": "Elasticsearch is a powerful search engine...",
    "tags": ["search", "elasticsearch", "tutorial"],
    "views": 1250,
    "rating": 4.5
}
```

### Key Points about Documents:

- Documents are expressed in JSON format
- Each document has a unique ID (auto-generated or specified)
- Documents are schema-free but benefit from explicit mapping
- Similar to a row in a relational database

## Indices

An **index** is a collection of documents with similar characteristics. Think of it as a database in traditional systems.

```{python}
#| echo: true
#| eval: false

# Index naming conventions
index_name = "blog_posts"  # lowercase, no special characters

# Multiple indices can exist
indices = [
    "blog_posts",
    "user_profiles",
    "product_catalog",
    "log_data_2024"
]
```

### Index Characteristics:

- Identified by a lowercase name
- Contains documents of similar type
- Can be optimized for specific use cases
- Supports custom settings and mappings

## Mapping

**Mapping** defines how documents and their fields are stored and indexed. It's similar to a schema in relational databases.

```{python}
#| echo: true
#| eval: false

# Example mapping definition
mapping = {
    "properties": {
        "title": {
            "type": "text",
            "analyzer": "english"
        },
        "author": {
            "type": "keyword"  # Not analyzed, exact matches
        },
        "published_date": {
            "type": "date",
            "format": "yyyy-MM-dd"
        },
        "content": {
            "type": "text"
        },
        "tags": {
            "type": "keyword"
        },
        "views": {
            "type": "integer"
        },
        "rating": {
            "type": "float"
        }
    }
}
```

### Common Field Types:

| Type | Description | Example Use Case |
|------|-------------|------------------|
| `text` | Full-text searchable | Article content, descriptions |
| `keyword` | Exact value matching | Tags, categories, IDs |
| `date` | Date/time values | Published dates, timestamps |
| `integer`/`long` | Whole numbers | Counts, IDs |
| `float`/`double` | Decimal numbers | Ratings, prices |
| `boolean` | True/false | Flags, status |
| `object` | Nested JSON object | Complex structures |
| `geo_point` | Latitude/longitude | Location data |

## Shards and Replicas

Elasticsearch distributes data across **shards** for scalability and **replicas** for high availability.

### Shards

- An index is divided into multiple shards
- Each shard is a fully functional index
- Enables horizontal scaling
- Default: 1 primary shard per index

### Replicas

- Copies of primary shards
- Provides redundancy and increased search capacity
- Default: 1 replica per primary shard

```{python}
#| echo: true
#| eval: false

# Creating an index with custom shard settings
index_settings = {
    "settings": {
        "number_of_shards": 3,      # Primary shards
        "number_of_replicas": 2      # Replica copies
    },
    "mappings": {
        "properties": {
            "title": {"type": "text"},
            "content": {"type": "text"}
        }
    }
}

# Note: This is the structure; we'll see how to apply it in the next section
```

:::{.callout-note}
## Shard Strategy
- More shards = better distribution but higher overhead
- Choose shard count based on expected data volume
- Cannot change shard count after index creation (requires reindexing)
:::

## Nodes and Clusters

### Cluster

- A collection of nodes that work together
- Stores all your data
- Provides indexing and search capabilities
- Identified by a unique name

### Node

- A single server in the cluster
- Stores data and participates in indexing/searching
- Can have different roles:
  - **Master node**: Cluster management
  - **Data node**: Stores data and executes queries
  - **Ingest node**: Pre-processes documents
  - **Coordinating node**: Routes requests

```{python}
#| echo: true
#| eval: false

from elasticsearch import Elasticsearch

es = Elasticsearch(['http://localhost:9200'])

# Get cluster information
cluster_info = es.cluster.stats()

print(f"Cluster name: {cluster_info['cluster_name']}")
print(f"Number of nodes: {cluster_info['nodes']['count']['total']}")
print(f"Indices count: {cluster_info['indices']['count']}")

# Get node information
nodes = es.nodes.info()
for node_id, node_data in nodes['nodes'].items():
    print(f"Node: {node_data['name']}")
    print(f"  Roles: {', '.join(node_data['roles'])}")
```

## Inverted Index

Elasticsearch uses an **inverted index** for fast full-text searches.

### How it Works:

1. Text is analyzed and broken into terms
2. Terms are stored with references to documents
3. Searches look up terms in the index
4. Results are retrieved almost instantly

```{python}
#| echo: true
#| eval: false

# Example: How text is analyzed
text = "The quick brown fox jumps over the lazy dog"

# After analysis (simplified):
inverted_index = {
    "quick": ["doc1"],
    "brown": ["doc1"],
    "fox": ["doc1"],
    "jump": ["doc1"],  # stemmed from "jumps"
    "lazi": ["doc1"],  # stemmed from "lazy"
    "dog": ["doc1"]
}

# Note: Common words like "the", "over" are often removed (stop words)
```

## Analysis and Analyzers

**Analyzers** process text during indexing and searching. They consist of:

1. **Character filters**: Remove/replace characters
2. **Tokenizers**: Break text into tokens
3. **Token filters**: Modify tokens (lowercase, stemming, etc.)

```{python}
#| echo: true
#| eval: false

# Example: Testing an analyzer
analyze_request = {
    "analyzer": "english",
    "text": "The Quick Brown Foxes jumped over the lazy dogs"
}

# This would produce tokens like:
# ["quick", "brown", "fox", "jump", "lazi", "dog"]
# Notice: lowercase, stemmed, stop words removed
```

### Common Analyzers:

- `standard`: Default, good for most languages
- `english`: English language specific
- `keyword`: No analysis, exact matching
- `whitespace`: Split on whitespace only
- `simple`: Lowercase and split on non-letters

:::{.callout-tip}
## Understanding Analysis
Proper analyzer selection is crucial for good search results. Choose based on your data type and search requirements.
:::

## Data Types in Practice

Let's see how different data types affect searching:

```{python}
#| echo: true
#| eval: false

# Example mapping with different types
product_mapping = {
    "properties": {
        # Text: searchable, analyzed
        "description": {
            "type": "text",
            "analyzer": "english"
        },

        # Keyword: exact match, aggregations, sorting
        "category": {
            "type": "keyword"
        },

        # Multi-field: both text and keyword
        "name": {
            "type": "text",
            "fields": {
                "keyword": {
                    "type": "keyword"
                }
            }
        },

        # Numeric: range queries, aggregations
        "price": {
            "type": "float"
        },

        # Date: date math, range queries
        "created_at": {
            "type": "date"
        },

        # Boolean: true/false filters
        "in_stock": {
            "type": "boolean"
        },

        # Nested: complex objects
        "reviews": {
            "type": "nested",
            "properties": {
                "author": {"type": "keyword"},
                "rating": {"type": "integer"},
                "comment": {"type": "text"}
            }
        }
    }
}
```

## Summary

Key concepts to remember:

1. **Documents**: JSON objects containing your data
2. **Indices**: Collections of similar documents
3. **Mapping**: Schema definition for documents
4. **Shards**: Distribute data for scalability
5. **Replicas**: Provide redundancy and availability
6. **Nodes/Clusters**: Infrastructure components
7. **Inverted Index**: Data structure enabling fast searches
8. **Analyzers**: Text processing for search

:::{.callout-tip}
## Ready for Practice?
In the next section, we'll put these concepts into action by indexing and managing documents!
:::
