---
title: "Recherche & Requêtes"
format:
    html: default
    ipynb: default
---

## Introduction à la Recherche

Elasticsearch fournit un puissant Query DSL (Domain Specific Language) pour rechercher et filtrer les données. Explorons les différents types de requêtes.

## Recherche de Base : Tout Correspondre

La requête la plus simple retourne tous les documents :

```{python}
#| echo: true
#| eval: false

from elasticsearch import Elasticsearch

es = Elasticsearch(['http://localhost:9200'])

# Rechercher tous les documents
query = {
    "query": {
        "match_all": {}
    }
}

response = es.search(index="blog_posts", body=query)

print(f"Total de résultats : {response['hits']['total']['value']}")
for hit in response['hits']['hits']:
    print(f"ID : {hit['_id']}, Score : {hit['_score']}")
    print(f"Titre : {hit['_source']['title']}")
```

## Recherche Full-Text : Requête Match

La requête `match` est utilisée pour la recherche full-text :

```{python}
#| echo: true
#| eval: false

# Rechercher des documents contenant "elasticsearch"
query = {
    "query": {
        "match": {
            "content": "elasticsearch performance"
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Score : {hit['_score']:.2f}")
    print(f"Titre : {hit['_source']['title']}")
    print(f"Contenu : {hit['_source']['content'][:100]}...")
    print("---")
```

:::{.callout-note}
## Comportement de la Requête Match
La requête match analyse le texte de recherche et trouve les documents contenant l'un des termes. Les documents contenant plus de termes obtiennent un score plus élevé.
:::

## Recherche Multi-Champs : Requête Multi-Match

Rechercher sur plusieurs champs :

```{python}
#| echo: true
#| eval: false

# Rechercher dans le titre et le contenu
query = {
    "query": {
        "multi_match": {
            "query": "elasticsearch tutorial",
            "fields": ["title^2", "content"]  # ^2 booste la pertinence du titre
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Titre : {hit['_source']['title']}, Score : {hit['_score']:.2f}")
```

### Boost de Champs

```{python}
#| echo: true
#| eval: false

# Booster différents champs différemment
query = {
    "query": {
        "multi_match": {
            "query": "search optimization",
            "fields": [
                "title^3",      # Le titre est le plus important
                "tags^2",       # Les tags sont modérément importants
                "content"       # Le contenu a un poids par défaut
            ]
        }
    }
}
```

## Correspondance Exacte : Requête Term

Pour la correspondance exacte (utile avec les champs keyword) :

```{python}
#| echo: true
#| eval: false

# Trouver des documents par nom d'auteur exact
query = {
    "query": {
        "term": {
            "author": "Jane Smith"
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Titre : {hit['_source']['title']}")
    print(f"Auteur : {hit['_source']['author']}")
```

## Correspondances Exactes Multiples : Requête Terms

```{python}
#| echo: true
#| eval: false

# Trouver des documents avec des tags spécifiques
query = {
    "query": {
        "terms": {
            "tags": ["elasticsearch", "performance", "tutorial"]
        }
    }
}

response = es.search(index="blog_posts", body=query)
```

## Requêtes de Plage

Rechercher des valeurs dans une plage :

```{python}
#| echo: true
#| eval: false

# Trouver des articles avec des vues entre 1000 et 2000
query = {
    "query": {
        "range": {
            "views": {
                "gte": 1000,  # Supérieur ou égal
                "lte": 2000   # Inférieur ou égal
            }
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Titre : {hit['_source']['title']}")
    print(f"Vues : {hit['_source']['views']}")
```

### Requêtes de Plage de Dates

```{python}
#| echo: true
#| eval: false

# Trouver des articles publiés en janvier 2024
query = {
    "query": {
        "range": {
            "published_date": {
                "gte": "2024-01-01",
                "lt": "2024-02-01"
            }
        }
    }
}

# Utilisation de mathématiques de dates
query_with_math = {
    "query": {
        "range": {
            "published_date": {
                "gte": "now-30d/d",  # Les 30 derniers jours
                "lte": "now/d"       # Aujourd'hui
            }
        }
    }
}
```

## Requêtes Booléennes

Combiner plusieurs requêtes en utilisant la logique booléenne :

```{python}
#| echo: true
#| eval: false

# Requête complexe : doit correspondre au contenu, devrait correspondre aux tags, ne doit pas être d'un auteur spécifique
query = {
    "query": {
        "bool": {
            "must": [
                {"match": {"content": "elasticsearch"}}
            ],
            "should": [
                {"term": {"tags": "tutorial"}},
                {"term": {"tags": "beginner"}}
            ],
            "must_not": [
                {"term": {"author": "John Doe"}}
            ],
            "filter": [
                {"range": {"views": {"gte": 1000}}}
            ]
        }
    }
}

response = es.search(index="blog_posts", body=query)
```

### Clauses de Requête Booléenne

| Clause | Description | Affecte le Score |
|--------|-------------|------------------|
| `must` | Les documents doivent correspondre | Oui |
| `should` | Les documents devraient correspondre (boost) | Oui |
| `must_not` | Les documents ne doivent pas correspondre | Non |
| `filter` | Les documents doivent correspondre (mis en cache) | Non |

:::{.callout-tip}
## Filter vs Must
Utilisez `filter` pour les correspondances exactes et les plages lorsque vous n'avez pas besoin de scoring de pertinence. C'est plus rapide et mis en cache !
:::

## Correspondance de Phrase

Correspondre des phrases exactes dans l'ordre :

```{python}
#| echo: true
#| eval: false

# Trouver une phrase exacte
query = {
    "query": {
        "match_phrase": {
            "content": "search engine"
        }
    }
}

# Autoriser quelques mots entre (slop)
query_with_slop = {
    "query": {
        "match_phrase": {
            "content": {
                "query": "search engine",
                "slop": 2  # Autoriser jusqu'à 2 mots entre les termes
            }
        }
    }
}
```

## Requêtes de Préfixe et Wildcard

```{python}
#| echo: true
#| eval: false

# Requête de préfixe (termes commençant par...)
prefix_query = {
    "query": {
        "prefix": {
            "author": "Jane"
        }
    }
}

# Requête wildcard (* correspond à n'importe quelle séquence, ? correspond à un caractère)
wildcard_query = {
    "query": {
        "wildcard": {
            "author": "J*n*"
        }
    }
}

# Attention : Peut être lent sur de grands ensembles de données !
```

## Requêtes Floues

Gérer les fautes de frappe et les erreurs d'orthographe :

```{python}
#| echo: true
#| eval: false

# Recherche floue (autorise de petites différences)
query = {
    "query": {
        "fuzzy": {
            "title": {
                "value": "elasticsearh",  # Faute de frappe : 'c' manquant
                "fuzziness": "AUTO"       # S'ajuste automatiquement selon la longueur du terme
            }
        }
    }
}

# Ou utiliser fuzzy dans la requête match
fuzzy_match = {
    "query": {
        "match": {
            "title": {
                "query": "elasticsearh tutorial",
                "fuzziness": "AUTO"
            }
        }
    }
}
```

## Requête Exists

Trouver des documents avec un champ spécifique :

```{python}
#| echo: true
#| eval: false

# Trouver des documents qui ont le champ 'tags'
query = {
    "query": {
        "exists": {
            "field": "tags"
        }
    }
}

# Trouver des documents sans un champ (en utilisant bool + must_not)
query_missing = {
    "query": {
        "bool": {
            "must_not": {
                "exists": {
                    "field": "tags"
                }
            }
        }
    }
}
```

## Tri des Résultats

```{python}
#| echo: true
#| eval: false

# Trier par vues (décroissant)
query = {
    "query": {"match_all": {}},
    "sort": [
        {"views": {"order": "desc"}},
        {"_score": {"order": "desc"}}  # Puis par pertinence
    ]
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Vues : {hit['_source']['views']}, Titre : {hit['_source']['title']}")
```

## Pagination

```{python}
#| echo: true
#| eval: false

# Obtenir les résultats 10-20
query = {
    "query": {"match_all": {}},
    "from": 10,  # Ignorer les 10 premiers
    "size": 10   # Retourner 10 résultats
}

response = es.search(index="blog_posts", body=query)

print(f"Affichage des résultats 11-20 sur {response['hits']['total']['value']}")
```

### Search After (pour la pagination profonde)

```{python}
#| echo: true
#| eval: false

# Première requête
query = {
    "query": {"match_all": {}},
    "size": 10,
    "sort": [
        {"published_date": "desc"},
        {"_id": "desc"}  # Départageur
    ]
}

response = es.search(index="blog_posts", body=query)

# Obtenir les valeurs de tri du dernier résultat
if response['hits']['hits']:
    last_sort = response['hits']['hits'][-1]['sort']

    # Page suivante
    next_query = {
        "query": {"match_all": {}},
        "size": 10,
        "sort": [
            {"published_date": "desc"},
            {"_id": "desc"}
        ],
        "search_after": last_sort
    }

    next_response = es.search(index="blog_posts", body=next_query)
```

## Mise en Évidence

Mettre en évidence les termes correspondants dans les résultats :

```{python}
#| echo: true
#| eval: false

query = {
    "query": {
        "match": {
            "content": "elasticsearch performance"
        }
    },
    "highlight": {
        "fields": {
            "content": {
                "fragment_size": 150,
                "number_of_fragments": 3
            }
        },
        "pre_tags": ["<mark>"],
        "post_tags": ["</mark>"]
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Titre : {hit['_source']['title']}")
    if 'highlight' in hit:
        for fragment in hit['highlight']['content']:
            print(f"  ...{fragment}...")
```

## Filtrage de Source

Contrôler quels champs sont retournés :

```{python}
#| echo: true
#| eval: false

# Inclure uniquement des champs spécifiques
query = {
    "query": {"match_all": {}},
    "_source": ["title", "author", "published_date"]
}

# Exclure des champs spécifiques
query_exclude = {
    "query": {"match_all": {}},
    "_source": {
        "excludes": ["content"]
    }
}

# Inclure et exclure des motifs
query_patterns = {
    "query": {"match_all": {}},
    "_source": {
        "includes": ["title", "author*"],
        "excludes": ["*.raw"]
    }
}
```

## API Count

Compter les documents correspondants sans les récupérer :

```{python}
#| echo: true
#| eval: false

# Compter les documents correspondant à la requête
query = {
    "query": {
        "match": {
            "content": "elasticsearch"
        }
    }
}

count = es.count(index="blog_posts", body=query)
print(f"Documents correspondants : {count['count']}")
```

## Exemples de Recherche Pratiques

### Exemple 1 : Recherche de Blog avec Filtres

```{python}
#| echo: true
#| eval: false

def search_blog_posts(keyword, author=None, min_views=None, tags=None):
    """Rechercher des articles de blog avec des filtres optionnels"""

    # Construire la requête
    must_clauses = []
    filter_clauses = []

    # Recherche par mot-clé
    if keyword:
        must_clauses.append({
            "multi_match": {
                "query": keyword,
                "fields": ["title^2", "content"]
            }
        })

    # Filtre par auteur
    if author:
        filter_clauses.append({
            "term": {"author": author}
        })

    # Filtre de vues minimales
    if min_views:
        filter_clauses.append({
            "range": {"views": {"gte": min_views}}
        })

    # Filtre par tags
    if tags:
        filter_clauses.append({
            "terms": {"tags": tags}
        })

    query = {
        "query": {
            "bool": {
                "must": must_clauses if must_clauses else [{"match_all": {}}],
                "filter": filter_clauses
            }
        },
        "sort": [
            {"_score": {"order": "desc"}},
            {"views": {"order": "desc"}}
        ]
    }

    response = es.search(index="blog_posts", body=query)

    return [
        {
            "title": hit["_source"]["title"],
            "author": hit["_source"]["author"],
            "views": hit["_source"]["views"],
            "score": hit["_score"]
        }
        for hit in response["hits"]["hits"]
    ]

# Exemple d'utilisation
results = search_blog_posts(
    keyword="elasticsearch performance",
    min_views=1000,
    tags=["tutorial"]
)

for result in results:
    print(result)
```

### Exemple 2 : Recherche Avancée avec Boosting

```{python}
#| echo: true
#| eval: false

# Booster les documents récents et populaires
query = {
    "query": {
        "function_score": {
            "query": {
                "multi_match": {
                    "query": "elasticsearch",
                    "fields": ["title", "content"]
                }
            },
            "functions": [
                {
                    # Booster par vues
                    "field_value_factor": {
                        "field": "views",
                        "modifier": "log1p",
                        "factor": 0.1
                    }
                },
                {
                    # Booster les documents récents
                    "gauss": {
                        "published_date": {
                            "origin": "now",
                            "scale": "30d",
                            "decay": 0.5
                        }
                    }
                }
            ],
            "score_mode": "multiply",
            "boost_mode": "multiply"
        }
    }
}

response = es.search(index="blog_posts", body=query)
```

## Conseils de Performance des Requêtes

1. **Utilisez des filtres pour les correspondances exactes** - Ils sont mis en cache et plus rapides
2. **Limitez la taille des résultats** - Ne récupérez pas plus que nécessaire
3. **Utilisez le filtrage de source** - Récupérez uniquement les champs nécessaires
4. **Évitez les wildcards au début** - `*term` est lent
5. **Utilisez l'API scroll pour de grands ensembles de résultats** - Mieux que la pagination profonde

:::{.callout-tip}
## Prochaines Étapes
Maintenant que vous pouvez rechercher efficacement, apprenons comment analyser et agréger les données dans la section suivante !
:::

---

## Télécharger le Notebook

:::{.callout-note}
## Notebook Jupyter
Téléchargez cette section sous forme de notebook Jupyter interactif pour exécuter les exemples sur votre propre machine.

[Télécharger search.ipynb](search.ipynb){.btn .btn-primary download="search.ipynb"}
:::
