---
title: "Aggregations"
format:
    html: default
    ipynb: default
---

## Introduction to Aggregations

Aggregations provide analytics and statistics on your data. They enable you to build complex summaries of your data and answer questions like:

- What's the average number of views per blog post?
- How many posts are there per author?
- What's the distribution of posts over time?

## Types of Aggregations

1. **Metric Aggregations**: Calculate metrics (sum, avg, min, max, etc.)
2. **Bucket Aggregations**: Group documents into buckets
3. **Pipeline Aggregations**: Process outputs from other aggregations

## Metric Aggregations

### Basic Statistics

```{python}
#| echo: true
#| eval: false

from elasticsearch import Elasticsearch

es = Elasticsearch(['http://localhost:9200'])

# Calculate statistics on views
query = {
    "aggs": {
        "avg_views": {
            "avg": {"field": "views"}
        },
        "max_views": {
            "max": {"field": "views"}
        },
        "min_views": {
            "min": {"field": "views"}
        },
        "total_views": {
            "sum": {"field": "views"}
        }
    },
    "size": 0  # Don't return documents, only aggregations
}

response = es.search(index="blog_posts", body=query)

aggs = response['aggregations']
print(f"Average views: {aggs['avg_views']['value']:.2f}")
print(f"Max views: {aggs['max_views']['value']}")
print(f"Min views: {aggs['min_views']['value']}")
print(f"Total views: {aggs['total_views']['value']}")
```

### Stats Aggregation

Get all basic statistics in one aggregation:

```{python}
#| echo: true
#| eval: false

query = {
    "aggs": {
        "views_stats": {
            "stats": {"field": "views"}
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

stats = response['aggregations']['views_stats']
print(f"Count: {stats['count']}")
print(f"Min: {stats['min']}")
print(f"Max: {stats['max']}")
print(f"Avg: {stats['avg']:.2f}")
print(f"Sum: {stats['sum']}")
```

### Extended Stats

```{python}
#| echo: true
#| eval: false

query = {
    "aggs": {
        "views_extended_stats": {
            "extended_stats": {"field": "views"}
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

stats = response['aggregations']['views_extended_stats']
print(f"Std deviation: {stats['std_deviation']:.2f}")
print(f"Variance: {stats['variance']:.2f}")
print(f"Sum of squares: {stats['sum_of_squares']}")
```

### Value Count

Count non-null values:

```{python}
#| echo: true
#| eval: false

query = {
    "aggs": {
        "posts_with_tags": {
            "value_count": {"field": "tags"}
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)
print(f"Posts with tags: {response['aggregations']['posts_with_tags']['value']}")
```

## Bucket Aggregations

### Terms Aggregation

Group by field values (like SQL GROUP BY):

```{python}
#| echo: true
#| eval: false

# Group by author
query = {
    "aggs": {
        "posts_by_author": {
            "terms": {
                "field": "author",
                "size": 10  # Top 10 authors
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for bucket in response['aggregations']['posts_by_author']['buckets']:
    print(f"Author: {bucket['key']}, Posts: {bucket['doc_count']}")
```

### Terms with Metrics

Combine bucket and metric aggregations:

```{python}
#| echo: true
#| eval: false

# Posts per author with average views
query = {
    "aggs": {
        "posts_by_author": {
            "terms": {
                "field": "author",
                "size": 10,
                "order": {"avg_views": "desc"}  # Order by avg views
            },
            "aggs": {
                "avg_views": {
                    "avg": {"field": "views"}
                },
                "total_views": {
                    "sum": {"field": "views"}
                }
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for bucket in response['aggregations']['posts_by_author']['buckets']:
    print(f"Author: {bucket['key']}")
    print(f"  Posts: {bucket['doc_count']}")
    print(f"  Avg views: {bucket['avg_views']['value']:.2f}")
    print(f"  Total views: {bucket['total_views']['value']}")
    print("---")
```

### Range Aggregation

Group documents into ranges:

```{python}
#| echo: true
#| eval: false

# Group posts by view count ranges
query = {
    "aggs": {
        "views_ranges": {
            "range": {
                "field": "views",
                "ranges": [
                    {"to": 500, "key": "low"},
                    {"from": 500, "to": 1500, "key": "medium"},
                    {"from": 1500, "key": "high"}
                ]
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for bucket in response['aggregations']['views_ranges']['buckets']:
    print(f"{bucket['key']}: {bucket['doc_count']} posts")
```

### Date Histogram

Group by time intervals:

```{python}
#| echo: true
#| eval: false

# Posts per month
query = {
    "aggs": {
        "posts_over_time": {
            "date_histogram": {
                "field": "published_date",
                "calendar_interval": "month",
                "format": "yyyy-MM"
            },
            "aggs": {
                "total_views": {
                    "sum": {"field": "views"}
                }
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for bucket in response['aggregations']['posts_over_time']['buckets']:
    print(f"Month: {bucket['key_as_string']}")
    print(f"  Posts: {bucket['doc_count']}")
    print(f"  Total views: {bucket['total_views']['value']}")
```

### Histogram

Group numeric values into intervals:

```{python}
#| echo: true
#| eval: false

# Distribution of views in 500-view intervals
query = {
    "aggs": {
        "views_distribution": {
            "histogram": {
                "field": "views",
                "interval": 500
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for bucket in response['aggregations']['views_distribution']['buckets']:
    print(f"Views {bucket['key']}-{bucket['key']+500}: {bucket['doc_count']} posts")
```

### Filter Aggregation

Apply aggregations to a subset of documents:

```{python}
#| echo: true
#| eval: false

# Statistics only for popular posts
query = {
    "aggs": {
        "popular_posts": {
            "filter": {
                "range": {"views": {"gte": 1000}}
            },
            "aggs": {
                "avg_views": {
                    "avg": {"field": "views"}
                }
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

popular = response['aggregations']['popular_posts']
print(f"Popular posts count: {popular['doc_count']}")
print(f"Average views: {popular['avg_views']['value']:.2f}")
```

### Filters Aggregation

Multiple named filters:

```{python}
#| echo: true
#| eval: false

# Categorize posts by popularity
query = {
    "aggs": {
        "post_categories": {
            "filters": {
                "filters": {
                    "low_traffic": {"range": {"views": {"lt": 500}}},
                    "medium_traffic": {"range": {"views": {"gte": 500, "lt": 1500}}},
                    "high_traffic": {"range": {"views": {"gte": 1500}}}
                }
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for category, data in response['aggregations']['post_categories']['buckets'].items():
    print(f"{category}: {data['doc_count']} posts")
```

## Nested Aggregations

Combine multiple levels of aggregations:

```{python}
#| echo: true
#| eval: false

# Posts per author, then by tag
query = {
    "aggs": {
        "authors": {
            "terms": {
                "field": "author",
                "size": 10
            },
            "aggs": {
                "tags": {
                    "terms": {
                        "field": "tags",
                        "size": 5
                    },
                    "aggs": {
                        "avg_views": {
                            "avg": {"field": "views"}
                        }
                    }
                }
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for author_bucket in response['aggregations']['authors']['buckets']:
    print(f"\nAuthor: {author_bucket['key']} ({author_bucket['doc_count']} posts)")

    for tag_bucket in author_bucket['tags']['buckets']:
        print(f"  Tag: {tag_bucket['key']}")
        print(f"    Count: {tag_bucket['doc_count']}")
        print(f"    Avg views: {tag_bucket['avg_views']['value']:.2f}")
```

## Pipeline Aggregations

Process the output of other aggregations:

### Cumulative Sum

```{python}
#| echo: true
#| eval: false

# Cumulative views over time
query = {
    "aggs": {
        "posts_per_month": {
            "date_histogram": {
                "field": "published_date",
                "calendar_interval": "month"
            },
            "aggs": {
                "monthly_views": {
                    "sum": {"field": "views"}
                },
                "cumulative_views": {
                    "cumulative_sum": {
                        "buckets_path": "monthly_views"
                    }
                }
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

for bucket in response['aggregations']['posts_per_month']['buckets']:
    print(f"Month: {bucket['key_as_string']}")
    print(f"  Monthly: {bucket['monthly_views']['value']}")
    print(f"  Cumulative: {bucket['cumulative_views']['value']}")
```

### Moving Average

```{python}
#| echo: true
#| eval: false

# Moving average of views
query = {
    "aggs": {
        "posts_per_month": {
            "date_histogram": {
                "field": "published_date",
                "calendar_interval": "month"
            },
            "aggs": {
                "monthly_views": {
                    "sum": {"field": "views"}
                },
                "views_moving_avg": {
                    "moving_avg": {
                        "buckets_path": "monthly_views",
                        "window": 3  # 3-month moving average
                    }
                }
            }
        }
    },
    "size": 0
}
```

### Bucket Sort

Sort and limit buckets:

```{python}
#| echo: true
#| eval: false

# Top 5 authors by total views
query = {
    "aggs": {
        "authors": {
            "terms": {
                "field": "author",
                "size": 100  # Get all first
            },
            "aggs": {
                "total_views": {
                    "sum": {"field": "views"}
                },
                "top_authors": {
                    "bucket_sort": {
                        "sort": [{"total_views": {"order": "desc"}}],
                        "size": 5
                    }
                }
            }
        }
    },
    "size": 0
}
```

## Cardinality

Count unique values:

```{python}
#| echo: true
#| eval: false

# Count unique authors and tags
query = {
    "aggs": {
        "unique_authors": {
            "cardinality": {"field": "author"}
        },
        "unique_tags": {
            "cardinality": {"field": "tags"}
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

print(f"Unique authors: {response['aggregations']['unique_authors']['value']}")
print(f"Unique tags: {response['aggregations']['unique_tags']['value']}")
```

## Percentiles

Calculate percentile values:

```{python}
#| echo: true
#| eval: false

# View count percentiles
query = {
    "aggs": {
        "views_percentiles": {
            "percentiles": {
                "field": "views",
                "percents": [25, 50, 75, 95, 99]
            }
        }
    },
    "size": 0
}

response = es.search(index="blog_posts", body=query)

percentiles = response['aggregations']['views_percentiles']['values']
for percentile, value in percentiles.items():
    print(f"{percentile}th percentile: {value:.2f} views")
```

## Practical Examples

### Example 1: Blog Analytics Dashboard

```{python}
#| echo: true
#| eval: false

def get_blog_analytics():
    """Comprehensive blog analytics"""

    query = {
        "aggs": {
            # Overall statistics
            "total_views": {"sum": {"field": "views"}},
            "avg_views": {"avg": {"field": "views"}},

            # Top authors
            "top_authors": {
                "terms": {
                    "field": "author",
                    "size": 5,
                    "order": {"total_views": "desc"}
                },
                "aggs": {
                    "total_views": {"sum": {"field": "views"}},
                    "avg_views": {"avg": {"field": "views"}}
                }
            },

            # Popular tags
            "popular_tags": {
                "terms": {
                    "field": "tags",
                    "size": 10
                },
                "aggs": {
                    "avg_views": {"avg": {"field": "views"}}
                }
            },

            # Posts over time
            "posts_timeline": {
                "date_histogram": {
                    "field": "published_date",
                    "calendar_interval": "month"
                },
                "aggs": {
                    "monthly_views": {"sum": {"field": "views"}}
                }
            },

            # View distribution
            "view_ranges": {
                "range": {
                    "field": "views",
                    "ranges": [
                        {"to": 500, "key": "0-500"},
                        {"from": 500, "to": 1000, "key": "500-1000"},
                        {"from": 1000, "to": 2000, "key": "1000-2000"},
                        {"from": 2000, "key": "2000+"}
                    ]
                }
            }
        },
        "size": 0
    }

    response = es.search(index="blog_posts", body=query)
    return response['aggregations']

# Get analytics
analytics = get_blog_analytics()

print("=== BLOG ANALYTICS ===\n")

print(f"Total views: {analytics['total_views']['value']:.0f}")
print(f"Average views: {analytics['avg_views']['value']:.2f}\n")

print("Top Authors:")
for bucket in analytics['top_authors']['buckets']:
    print(f"  {bucket['key']}: {bucket['doc_count']} posts, "
          f"{bucket['total_views']['value']:.0f} total views")

print("\nPopular Tags:")
for bucket in analytics['popular_tags']['buckets'][:5]:
    print(f"  {bucket['key']}: {bucket['doc_count']} posts, "
          f"{bucket['avg_views']['value']:.2f} avg views")
```

### Example 2: Time-based Analysis with Visualization

```{python}
#| echo: true
#| eval: false

import matplotlib.pyplot as plt
from datetime import datetime

def analyze_posting_trends():
    """Analyze posting trends over time"""

    query = {
        "aggs": {
            "posts_by_month": {
                "date_histogram": {
                    "field": "published_date",
                    "calendar_interval": "month",
                    "format": "yyyy-MM"
                },
                "aggs": {
                    "total_views": {"sum": {"field": "views"}},
                    "avg_views": {"avg": {"field": "views"}}
                }
            }
        },
        "size": 0
    }

    response = es.search(index="blog_posts", body=query)

    # Extract data
    buckets = response['aggregations']['posts_by_month']['buckets']

    months = [b['key_as_string'] for b in buckets]
    post_counts = [b['doc_count'] for b in buckets]
    total_views = [b['total_views']['value'] for b in buckets]

    # Create visualization
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # Posts per month
    ax1.bar(months, post_counts, color='steelblue')
    ax1.set_xlabel('Month')
    ax1.set_ylabel('Number of Posts')
    ax1.set_title('Posts per Month')
    ax1.tick_params(axis='x', rotation=45)

    # Views per month
    ax2.plot(months, total_views, marker='o', color='coral', linewidth=2)
    ax2.set_xlabel('Month')
    ax2.set_ylabel('Total Views')
    ax2.set_title('Views per Month')
    ax2.tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.savefig('blog_trends.png')
    print("Visualization saved as 'blog_trends.png'")

    return {
        "months": months,
        "posts": post_counts,
        "views": total_views
    }

# Note: Uncomment to run with actual data
# analyze_posting_trends()
```

## Aggregation Best Practices

:::{.callout-tip}
## Performance Tips

1. **Use `size: 0`** when you only need aggregations, not documents
2. **Limit bucket sizes** with the `size` parameter in terms aggregations
3. **Use filters** to reduce the dataset before aggregating
4. **Cache filter aggregations** by using the filter context
5. **Consider doc values** - enabled by default for keyword and numeric fields
:::

### Example: Efficient Aggregation

```{python}
#| echo: true
#| eval: false

# Good: Focused aggregation with filters
efficient_query = {
    "query": {
        "range": {
            "published_date": {"gte": "2024-01-01"}
        }
    },
    "aggs": {
        "recent_authors": {
            "terms": {
                "field": "author",
                "size": 10  # Limit results
            }
        }
    },
    "size": 0  # No documents needed
}

# Avoid: Unbounded aggregations
# "terms": {"field": "author"}  # No size limit
```

:::{.callout-tip}
## Next Steps
Congratulations! You now understand the fundamentals of Elasticsearch. Check out the Advanced Topics section for clustering, optimization, and production best practices.
:::

---

## Download Notebook

:::{.callout-note}
## Jupyter Notebook
Download this section as an interactive Jupyter notebook to run the examples on your own machine.

[Download aggregations.ipynb](aggregations.ipynb){.btn .btn-primary download="aggregations.ipynb"}
:::
