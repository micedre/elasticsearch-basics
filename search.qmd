---
title: "Search & Queries"
format:
    html: default
    ipynb: default
---

## Introduction to Search

Elasticsearch provides a powerful Query DSL (Domain Specific Language) for searching and filtering data. Let's explore the different types of queries.

## Basic Search: Match All

The simplest query returns all documents:

```{python}
#| echo: true
#| eval: false

from elasticsearch import Elasticsearch

es = Elasticsearch(['http://localhost:9200'])

# Search all documents
query = {
    "query": {
        "match_all": {}
    }
}

response = es.search(index="blog_posts", body=query)

print(f"Total hits: {response['hits']['total']['value']}")
for hit in response['hits']['hits']:
    print(f"ID: {hit['_id']}, Score: {hit['_score']}")
    print(f"Title: {hit['_source']['title']}")
```

## Full-Text Search: Match Query

The `match` query is used for full-text search:

```{python}
#| echo: true
#| eval: false

# Search for documents containing "elasticsearch"
query = {
    "query": {
        "match": {
            "content": "elasticsearch performance"
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Score: {hit['_score']:.2f}")
    print(f"Title: {hit['_source']['title']}")
    print(f"Content: {hit['_source']['content'][:100]}...")
    print("---")
```

:::{.callout-note}
## Match Query Behavior
The match query analyzes the search text and finds documents containing any of the terms. Documents containing more terms score higher.
:::

## Multi-Field Search: Multi-Match Query

Search across multiple fields:

```{python}
#| echo: true
#| eval: false

# Search in both title and content
query = {
    "query": {
        "multi_match": {
            "query": "elasticsearch tutorial",
            "fields": ["title^2", "content"]  # ^2 boosts title relevance
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Title: {hit['_source']['title']}, Score: {hit['_score']:.2f}")
```

### Field Boosting

```{python}
#| echo: true
#| eval: false

# Boost different fields differently
query = {
    "query": {
        "multi_match": {
            "query": "search optimization",
            "fields": [
                "title^3",      # Title is most important
                "tags^2",       # Tags are moderately important
                "content"       # Content has default weight
            ]
        }
    }
}
```

## Exact Match: Term Query

For exact matching (useful with keyword fields):

```{python}
#| echo: true
#| eval: false

# Find documents by exact author name
query = {
    "query": {
        "term": {
            "author": "Jane Smith"
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Title: {hit['_source']['title']}")
    print(f"Author: {hit['_source']['author']}")
```

## Multiple Exact Matches: Terms Query

```{python}
#| echo: true
#| eval: false

# Find documents with specific tags
query = {
    "query": {
        "terms": {
            "tags": ["elasticsearch", "performance", "tutorial"]
        }
    }
}

response = es.search(index="blog_posts", body=query)
```

## Range Queries

Search for values within a range:

```{python}
#| echo: true
#| eval: false

# Find posts with views between 1000 and 2000
query = {
    "query": {
        "range": {
            "views": {
                "gte": 1000,  # Greater than or equal
                "lte": 2000   # Less than or equal
            }
        }
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Title: {hit['_source']['title']}")
    print(f"Views: {hit['_source']['views']}")
```

### Date Range Queries

```{python}
#| echo: true
#| eval: false

# Find posts published in January 2024
query = {
    "query": {
        "range": {
            "published_date": {
                "gte": "2024-01-01",
                "lt": "2024-02-01"
            }
        }
    }
}

# Using date math
query_with_math = {
    "query": {
        "range": {
            "published_date": {
                "gte": "now-30d/d",  # Last 30 days
                "lte": "now/d"       # Today
            }
        }
    }
}
```

## Boolean Queries

Combine multiple queries using Boolean logic:

```{python}
#| echo: true
#| eval: false

# Complex query: must match content, should match tags, must not be by specific author
query = {
    "query": {
        "bool": {
            "must": [
                {"match": {"content": "elasticsearch"}}
            ],
            "should": [
                {"term": {"tags": "tutorial"}},
                {"term": {"tags": "beginner"}}
            ],
            "must_not": [
                {"term": {"author": "John Doe"}}
            ],
            "filter": [
                {"range": {"views": {"gte": 1000}}}
            ]
        }
    }
}

response = es.search(index="blog_posts", body=query)
```

### Boolean Query Clauses

| Clause | Description | Affects Score |
|--------|-------------|---------------|
| `must` | Documents must match | Yes |
| `should` | Documents should match (boost) | Yes |
| `must_not` | Documents must not match | No |
| `filter` | Documents must match (cached) | No |

:::{.callout-tip}
## Filter vs Must
Use `filter` for exact matches and ranges when you don't need relevance scoring. It's faster and cached!
:::

## Phrase Matching

Match exact phrases in order:

```{python}
#| echo: true
#| eval: false

# Find exact phrase
query = {
    "query": {
        "match_phrase": {
            "content": "search engine"
        }
    }
}

# Allow some words in between (slop)
query_with_slop = {
    "query": {
        "match_phrase": {
            "content": {
                "query": "search engine",
                "slop": 2  # Allow up to 2 words between terms
            }
        }
    }
}
```

## Prefix and Wildcard Queries

```{python}
#| echo: true
#| eval: false

# Prefix query (terms starting with...)
prefix_query = {
    "query": {
        "prefix": {
            "author": "Jane"
        }
    }
}

# Wildcard query (* matches any sequence, ? matches one character)
wildcard_query = {
    "query": {
        "wildcard": {
            "author": "J*n*"
        }
    }
}

# Warning: Can be slow on large datasets!
```

## Fuzzy Queries

Handle typos and misspellings:

```{python}
#| echo: true
#| eval: false

# Fuzzy search (allows small differences)
query = {
    "query": {
        "fuzzy": {
            "title": {
                "value": "elasticsearh",  # Typo: missing 'c'
                "fuzziness": "AUTO"       # Auto-adjusts based on term length
            }
        }
    }
}

# Or use fuzzy in match query
fuzzy_match = {
    "query": {
        "match": {
            "title": {
                "query": "elasticsearh tutorial",
                "fuzziness": "AUTO"
            }
        }
    }
}
```

## Exists Query

Find documents with a specific field:

```{python}
#| echo: true
#| eval: false

# Find documents that have the 'tags' field
query = {
    "query": {
        "exists": {
            "field": "tags"
        }
    }
}

# Find documents missing a field (using bool + must_not)
query_missing = {
    "query": {
        "bool": {
            "must_not": {
                "exists": {
                    "field": "tags"
                }
            }
        }
    }
}
```

## Sorting Results

```{python}
#| echo: true
#| eval: false

# Sort by views (descending)
query = {
    "query": {"match_all": {}},
    "sort": [
        {"views": {"order": "desc"}},
        {"_score": {"order": "desc"}}  # Then by relevance
    ]
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Views: {hit['_source']['views']}, Title: {hit['_source']['title']}")
```

## Pagination

```{python}
#| echo: true
#| eval: false

# Get results 10-20
query = {
    "query": {"match_all": {}},
    "from": 10,  # Skip first 10
    "size": 10   # Return 10 results
}

response = es.search(index="blog_posts", body=query)

print(f"Showing results 11-20 of {response['hits']['total']['value']}")
```

### Search After (for deep pagination)

```{python}
#| echo: true
#| eval: false

# First request
query = {
    "query": {"match_all": {}},
    "size": 10,
    "sort": [
        {"published_date": "desc"},
        {"_id": "desc"}  # Tiebreaker
    ]
}

response = es.search(index="blog_posts", body=query)

# Get last hit's sort values
if response['hits']['hits']:
    last_sort = response['hits']['hits'][-1]['sort']

    # Next page
    next_query = {
        "query": {"match_all": {}},
        "size": 10,
        "sort": [
            {"published_date": "desc"},
            {"_id": "desc"}
        ],
        "search_after": last_sort
    }

    next_response = es.search(index="blog_posts", body=next_query)
```

## Highlighting

Highlight matching terms in results:

```{python}
#| echo: true
#| eval: false

query = {
    "query": {
        "match": {
            "content": "elasticsearch performance"
        }
    },
    "highlight": {
        "fields": {
            "content": {
                "fragment_size": 150,
                "number_of_fragments": 3
            }
        },
        "pre_tags": ["<mark>"],
        "post_tags": ["</mark>"]
    }
}

response = es.search(index="blog_posts", body=query)

for hit in response['hits']['hits']:
    print(f"Title: {hit['_source']['title']}")
    if 'highlight' in hit:
        for fragment in hit['highlight']['content']:
            print(f"  ...{fragment}...")
```

## Source Filtering

Control which fields are returned:

```{python}
#| echo: true
#| eval: false

# Include only specific fields
query = {
    "query": {"match_all": {}},
    "_source": ["title", "author", "published_date"]
}

# Exclude specific fields
query_exclude = {
    "query": {"match_all": {}},
    "_source": {
        "excludes": ["content"]
    }
}

# Include and exclude patterns
query_patterns = {
    "query": {"match_all": {}},
    "_source": {
        "includes": ["title", "author*"],
        "excludes": ["*.raw"]
    }
}
```

## Count API

Count matching documents without retrieving them:

```{python}
#| echo: true
#| eval: false

# Count documents matching query
query = {
    "query": {
        "match": {
            "content": "elasticsearch"
        }
    }
}

count = es.count(index="blog_posts", body=query)
print(f"Matching documents: {count['count']}")
```

## Practical Search Examples

### Example 1: Blog Search with Filters

```{python}
#| echo: true
#| eval: false

def search_blog_posts(keyword, author=None, min_views=None, tags=None):
    """Search blog posts with optional filters"""

    # Build the query
    must_clauses = []
    filter_clauses = []

    # Keyword search
    if keyword:
        must_clauses.append({
            "multi_match": {
                "query": keyword,
                "fields": ["title^2", "content"]
            }
        })

    # Author filter
    if author:
        filter_clauses.append({
            "term": {"author": author}
        })

    # Minimum views filter
    if min_views:
        filter_clauses.append({
            "range": {"views": {"gte": min_views}}
        })

    # Tags filter
    if tags:
        filter_clauses.append({
            "terms": {"tags": tags}
        })

    query = {
        "query": {
            "bool": {
                "must": must_clauses if must_clauses else [{"match_all": {}}],
                "filter": filter_clauses
            }
        },
        "sort": [
            {"_score": {"order": "desc"}},
            {"views": {"order": "desc"}}
        ]
    }

    response = es.search(index="blog_posts", body=query)

    return [
        {
            "title": hit["_source"]["title"],
            "author": hit["_source"]["author"],
            "views": hit["_source"]["views"],
            "score": hit["_score"]
        }
        for hit in response["hits"]["hits"]
    ]

# Example usage
results = search_blog_posts(
    keyword="elasticsearch performance",
    min_views=1000,
    tags=["tutorial"]
)

for result in results:
    print(result)
```

### Example 2: Advanced Search with Boosting

```{python}
#| echo: true
#| eval: false

# Boost recent documents and popular ones
query = {
    "query": {
        "function_score": {
            "query": {
                "multi_match": {
                    "query": "elasticsearch",
                    "fields": ["title", "content"]
                }
            },
            "functions": [
                {
                    # Boost by views
                    "field_value_factor": {
                        "field": "views",
                        "modifier": "log1p",
                        "factor": 0.1
                    }
                },
                {
                    # Boost recent documents
                    "gauss": {
                        "published_date": {
                            "origin": "now",
                            "scale": "30d",
                            "decay": 0.5
                        }
                    }
                }
            ],
            "score_mode": "multiply",
            "boost_mode": "multiply"
        }
    }
}

response = es.search(index="blog_posts", body=query)
```

## Query Performance Tips

1. **Use filters for exact matches** - They're cached and faster
2. **Limit result size** - Don't fetch more than you need
3. **Use source filtering** - Only retrieve necessary fields
4. **Avoid wildcards at the beginning** - `*term` is slow
5. **Use scroll API for large result sets** - Better than deep pagination

:::{.callout-tip}
## Next Steps
Now that you can search effectively, let's learn how to analyze and aggregate data in the next section!
:::

---

## Download Notebook

:::{.callout-note}
## Jupyter Notebook
Download this section as an interactive Jupyter notebook to run the examples on your own machine.

[Download search.ipynb](search.ipynb){.btn .btn-primary download="search.ipynb"}
:::
